<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Finger Counter Final - Auto Start</title>
<style>
/* Use flexbox for simple, performant centering and layout */
html, body { 
    margin: 0; 
    height: 100%; 
    overflow: hidden; 
    background: black; 
    display: flex; 
    justify-content: center;
    align-items: center;
}
 
/* Keep canvas minimal and let JS/flexbox handle sizing */
canvas { 
    display: block; 
    position: absolute; 
    top: 0; 
    left: 0;
    z-index: 50; 
    width: 100%; 
    height: 100%;
}
 
/* No changes to button style */
#fullscreen-btn {
    position: absolute;
    top: 10px;
    right: 10px;
    z-index: 100;
    padding: 10px 20px;
    font-size: 16px;
    background-color: #2ECC71; 
    color: white;
    border: none;
    border-radius: 5px;
    cursor: pointer;
    transition: opacity 0.3s;
    opacity: 1; 
}

.hidden {
    display: none !important;
}
</style>
<link rel="preconnect" href="https://cdn.jsdelivr.net">
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
</head>
<body>
<video id="video" autoplay playsinline style="display:none;"></video>
<canvas id="canvas"></canvas>

<button id="fullscreen-btn">Go Fullscreen</button>

<script>
// --- Core Setup ---

const videoElement = document.getElementById('video');
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d', { alpha: false }); 

const fullscreenBtn = document.getElementById('fullscreen-btn');
let camera = null; 
let totalFingers = 0; 
let handCount = 0;

const tips = [4, 8, 12, 16, 20];
const pips = [3, 6, 10, 14, 18]; 
const HAND_CONNECTIONS = window.HAND_CONNECTIONS; 

// NEW: Image variable and pre-loading
const middleFingerImage = new Image();
middleFingerImage.src = 'middlefinger.jpg';
let imageLoaded = false;
middleFingerImage.onload = () => {
    imageLoaded = true;
};


// --- Fullscreen and UI Management (Unchanged) ---

function toggleFullscreen() {
    if (!document.fullscreenElement) {
        document.documentElement.requestFullscreen().catch(err => {
            console.error("Fullscreen blocked. User must click to activate.");
            fullscreenBtn.classList.remove('hidden');
        });
    } else if (document.exitFullscreen) {
        document.exitFullscreen();
    }
}

function handleFullscreenChange() {
    if (document.fullscreenElement) {
        fullscreenBtn.classList.add('hidden');
    } else {
        fullscreenBtn.classList.remove('hidden');
    }
    resizeCanvas();
}

fullscreenBtn.addEventListener('click', toggleFullscreen);
document.addEventListener('fullscreenchange', handleFullscreenChange);
document.addEventListener('webkitfullscreenchange', handleFullscreenChange);


function resizeCanvas() {
    const newWidth = window.innerWidth;
    const newHeight = window.innerHeight;

    if (canvas.width !== newWidth || canvas.height !== newHeight) {
        canvas.width = newWidth;
        canvas.height = newHeight;
    }
}

let resizeTimeout;
window.addEventListener('resize', () => {
    clearTimeout(resizeTimeout);
    resizeTimeout = setTimeout(resizeCanvas, 100); 
});

// --- FingerCounter Logic (MODIFIED to detect the gesture) ---

function distance(p1, p2) {
    return Math.hypot(p1.x - p2.x, p1.y - p2.y);
}

/**
 * Counts fingers up and detects the 'middle finger' gesture.
 * @param {Array<Object>} lm - The hand landmarks.
 * @returns {{fingersUp: number, isMiddleFinger: boolean}}
 */
function countFingers(lm) {
    let fingersUp = 0; 
    const fingerStates = [false, false, false, false, false]; // [Thumb, Index, Middle, Ring, Pinky]
    const wrist = lm[0];
    
    // Thumb logic
    const thumbTipX = lm[tips[0]].x;
    const thumbPipX = lm[pips[0]].x;
    const wristX = lm[0].x;

    if (lm[2].x > wristX) {
        if (thumbTipX > thumbPipX) {
            fingersUp++;
            fingerStates[0] = true;
        }
    } else {
        if (thumbTipX < thumbPipX) {
            fingersUp++;
            fingerStates[0] = true;
        }
    }

    // Other 4 fingers
    for (let i = 1; i < 5; i++) {
        const tip = lm[tips[i]];
        const pip = lm[pips[i]];
        
        const tipToWristDist = distance(tip, wrist);
        const pipToWristDist = distance(pip, wrist);

        if (tipToWristDist > pipToWristDist) {
            fingersUp++;
            fingerStates[i] = true;
        }
    }
    
    // NEW LOGIC: Check for the 'middle finger' gesture: ONLY the middle finger is up (index = 2)
    // The gesture is considered a 'middle finger' if only the middle finger (index 2) is up.
    // The condition is: All fingers are down EXCEPT the middle finger.
    const isMiddleFinger = (
        !fingerStates[0] && // Thumb down
        !fingerStates[1] && // Index down
        fingerStates[2] &&  // Middle UP
        !fingerStates[3] && // Ring down
        !fingerStates[4]    // Pinky down
    );

    return { fingersUp, isMiddleFinger };
}

function calculateHandScale(landmarks) {
    const p0 = landmarks[0];
    const p5 = landmarks[5];
    return distance(p0, p5); 
}

// --- MediaPipe and Rendering Setup (MODIFIED to use the image) ---

const hands = new Hands({
    locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`
});

hands.setOptions({
    modelComplexity: 0, 
    minDetectionConfidence: 0.6, 
    minTrackingConfidence: 0.4,
    // Max hands set high to accommodate many users/hands
    maxNumHands: 21 
});

hands.onResults(results => {
    requestAnimationFrame(() => {
        
        ctx.save();
        
        // 1. Clear the canvas with a solid black fill
        ctx.fillStyle = 'black';
        ctx.fillRect(0, 0, canvas.width, canvas.height); 
        
        // --- Aspect Ratio Correction Logic ---
        const videoW = videoElement.videoWidth;
        const videoH = videoElement.videoHeight;
        const videoRatio = videoW / videoH;
        const canvasRatio = canvas.width / canvas.height;
        
        let drawWidth, drawHeight, offsetX, offsetY;
        
        if (videoRatio > canvasRatio) {
            drawWidth = canvas.width;
            drawHeight = drawWidth / videoRatio;
            offsetX = 0;
            offsetY = (canvas.height - drawHeight) / 2;
        } else {
            drawHeight = canvas.height;
            drawWidth = drawHeight * videoRatio;
            offsetY = 0;
            offsetX = (canvas.width - drawWidth) / 2;
        }
        // --- End Aspect Ratio Correction Logic ---
        
        // 2. Flip the drawing space (mirrors video and hand landmarks)
        ctx.translate(canvas.width, 0);
        ctx.scale(-1, 1);
        
        // 3. Draw the video frame
        // NOTE: We do NOT draw the video frame here anymore, 
        // as we will draw the image or the video on a per-hand basis later.
        
        totalFingers = 0;
        handCount = 0;
        
        if (results.multiHandLandmarks) {
            
            // NEW: Separate landmarks into two groups: those with the gesture, and the rest.
            const handsToCensor = [];
            const handsToDraw = [];

            for (const landmarks of results.multiHandLandmarks) {
                const { fingersUp, isMiddleFinger } = countFingers(landmarks);
                
                if (isMiddleFinger && imageLoaded) {
                    handsToCensor.push({ landmarks, fingersUp });
                } else {
                    handsToDraw.push({ landmarks, fingersUp });
                }
            }

            // A. Draw the **uncensored** video/image
            const flippedOffsetX = (canvas.width - offsetX) - drawWidth;
            ctx.drawImage(results.image, flippedOffsetX, offsetY, drawWidth, drawHeight); 

            handCount = results.multiHandLandmarks.length;
            
            // Set font and color for hand-level count (Green: #00FF00)
            ctx.fillStyle = '#00FF00'; 
            ctx.font = `bold 56px Arial`; 

            // B. Draw hands that are NOT censored (regular drawing)
            for (const { landmarks, fingersUp } of handsToDraw) {
                totalFingers += fingersUp;
                
                // Calculate the dynamic radius based on hand scale
                const handScale = calculateHandScale(landmarks);
                const baseRadius = Math.max(3, Math.min(10, handScale * 25)); 
                
                // 4. Draw Hand Visualization (White Lines, Dynamic Red Points)
                ctx.save();
                
                // Scale and translate the drawing context to align with the video.
                const scaleX = drawWidth / videoW;
                const scaleY = drawHeight / videoH;

                ctx.translate(canvas.width - offsetX - drawWidth, offsetY); 
                ctx.scale(scaleX * (videoW / canvas.width), scaleY * (videoH / canvas.height)); 
                
                drawConnectors(ctx, landmarks, HAND_CONNECTIONS, {color: '#FFFFFF', lineWidth: 4}); 
                
                // Use the calculated baseRadius for the dots
                drawLandmarks(ctx, landmarks, {
                    color: '#FF0000', 
                    lineWidth: 2, 
                    radius: baseRadius
                }); 
                
                // Restore state before drawing text
                ctx.restore();
                ctx.save(); 

                // 5. Text Position: Center of the palm (Landmark 9)
                const cx = (landmarks[9].x * drawWidth) + offsetX;
                const cy = (landmarks[9].y * drawHeight) + offsetY;
                
                // Temporary anti-flip transformation for text
                ctx.translate(cx, cy);
                ctx.scale(-1, 1); 
                
                // Draw text 
                ctx.fillText(String(fingersUp), -30, -30);

                // Restore the state
                ctx.restore();
            }

            // C. Draw the hands that ARE censored (draw the image over the hand area)
            for (const { landmarks } of handsToCensor) {
                // The 'middle finger' gesture means fingersUp is 1, so count it toward the total.
                totalFingers += 1; 

                // Determine the hand bounding box (approximate)
                let minX = Infinity, minY = Infinity;
                let maxX = -Infinity, maxY = -Infinity;

                for (const point of landmarks) {
                    minX = Math.min(minX, point.x);
                    minY = Math.min(minY, point.y);
                    maxX = Math.max(maxX, point.x);
                    maxY = Math.max(maxY, point.y);
                }

                // Convert normalized coordinates [0, 1] to canvas coordinates
                const x_norm = minX;
                const y_norm = minY;
                const width_norm = maxX - minX;
                const height_norm = maxY - minY;

                const drawX = (x_norm * drawWidth) + offsetX;
                const drawY = (y_norm * drawHeight) + offsetY;
                const rectWidth = width_norm * drawWidth;
                const rectHeight = height_norm * drawHeight;

                // NEW: Draw the image over the hand area
                ctx.drawImage(
                    middleFingerImage, 
                    drawX, 
                    drawY, 
                    rectWidth, 
                    rectHeight
                );

                // You might also want to draw a text overlay that's censored, or nothing.
                // Let's draw 'X' to indicate it's censored.
                ctx.save();
                ctx.fillStyle = '#FF0000'; // Red color
                ctx.font = `bold ${rectHeight * 0.4}px Arial`; 
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                
                // Text position (approximate center of the censored area)
                const textCenterX = drawX + rectWidth / 2;
                const textCenterY = drawY + rectHeight / 2;

                // Temporary anti-flip transformation for text
                ctx.translate(textCenterX, textCenterY);
                ctx.scale(-1, 1); 

                ctx.fillText('X', 0, 0); 
                ctx.restore();
            }
        } else {
            // If no hands, draw the video frame as the background
            const flippedOffsetX = (canvas.width - offsetX) - drawWidth;
            ctx.drawImage(results.image, flippedOffsetX, offsetY, drawWidth, drawHeight);
        }
        
        // 6. Restore the canvas transform (undo the main video flip)
        ctx.restore(); 
        
        // --- Draw Total Counts (Blue) ---
        
        // Set font for total count (Blue: #0000FF)
        ctx.fillStyle = '#0000FF'; 
        ctx.font = `bold 30px Arial`; 

        // CALCULATE POSITION: 
        const textX = offsetX + 20; 
        const textY1 = offsetY + 30; 
        const textY2 = offsetY + 70; 

        // Draw the text at the new calculated coordinates
        ctx.fillText(`Total Fingers: ${totalFingers}`, textX, textY1); 
        ctx.fillText(`Hands Detected: ${handCount}`, textX, textY2); 

    }); // End requestAnimationFrame
});

// --- Camera Initialization and Program Start (Unchanged) ---

const initCamera = async () => {
    try {
        const stream = await navigator.mediaDevices.getUserMedia({
            video: {
                width: { ideal: 1280, min: 640 },
                height: { ideal: 720, min: 480 },
                facingMode: 'user'
            }
        });
        
        videoElement.srcObject = stream;
        
        await new Promise((resolve) => {
            videoElement.onloadedmetadata = () => {
                videoElement.width = videoElement.videoWidth;
                videoElement.height = videoElement.videoHeight;
                resolve(true);
            };
        });

        camera = new Camera(videoElement, {
            onFrame: async () => {
                await hands.send({image: videoElement});
            },
            width: videoElement.width, 
            height: videoElement.height,
            mirrored: false
        });
        camera.start();
    } catch (e) {
        // Log a more informative message if camera access fails.
        console.error("Camera initialization failed. The browser likely blocked camera access until permission is granted.", e);
        // You could add a UI element here to prompt the user to refresh or click
    }
};

// Initial setup
resizeCanvas();

// ðŸ‘‡ NEW: Start the camera as soon as the window and its resources are loaded.
window.onload = () => {
    initCamera();
    handleFullscreenChange();
};

</script>
</body>
</html>